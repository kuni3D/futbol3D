<!DOCTYPE html>
<html>
<head>
    <title>Pelota y Arco de Fútbol con Banderín Animado</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .header {
            position: absolute; top: 10px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box; color: #808080; font-size: clamp(16px, 2vw, 18px);
            z-index: 1; pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div>Menu</div>
        <div>Log In / Sign Up</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 4096;
        directionalLight.shadow.mapSize.height = 4096;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 20;
        directionalLight.shadow.bias = -0.001;
        scene.add(directionalLight);

        let ball;
        let velocity = new THREE.Vector3(0, 0, 0);
        const speed = 0.3;
        const roomSizeX = 1.4;
        const roomSizeZ = 2.3;

        const loader = new THREE.GLTFLoader();
        let mixer;

        loader.load('pelotita2.glb', (gltf) => {
            const model = gltf.scene;
            console.log('Modelo cargado:', model);
            model.traverse((child) => {
                if (child.isMesh) {
                    console.log('Mesh encontrado:', child.name);
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            scene.add(model);

            ball = model.getObjectByName('pelota');
            if (!ball) console.error('No se encontró la pelota en el modelo');
            else console.log('Pelota asignada:', ball);

            const banderin = model.getObjectByName('banderin');
            if (!banderin) console.error('No se encontró el banderín en el modelo');

            if (banderin?.isMesh && banderin.morphTargetInfluences) {
                console.log("Morph targets del banderín cargados correctamente.");
            } else {
                console.error("El banderín no tiene morph targets.");
            }

            mixer = new THREE.AnimationMixer(model);
            if (gltf.animations.length > 0) {
                const clip = gltf.animations.find((clip) => clip.name === 'banderinflameo');
                if (clip) mixer.clipAction(clip).play();
                else console.error("No se encontró la animación del banderín.");
            } else {
                console.error("No se encontraron animaciones en el modelo.");
            }

            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
        }, undefined, (error) => {
            console.error('Error al cargar el modelo:', error);
        });

        // Definir el primer arco (lado z = -2.3)
        const goalWidth = 1.3;
        const goalHeight = 0.7;
        const goalDepth = 0.09;
        const postRadius = 0.05;

        const leftPostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32);
        const postMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const leftPost = new THREE.Mesh(leftPostGeometry, postMaterial);
        leftPost.position.set(-goalWidth / 2, goalHeight / 2, -2.3);
        scene.add(leftPost);

        const rightPostGeometry = new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32);
        const rightPost = new THREE.Mesh(rightPostGeometry, postMaterial);
        rightPost.position.set(goalWidth / 2, goalHeight / 2, -2.3);
        scene.add(rightPost);

        const crossbarGeometry = new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32);
        const crossbar = new THREE.Mesh(crossbarGeometry, postMaterial);
        crossbar.position.set(0, goalHeight, -2.3);
        crossbar.rotation.z = Math.PI / 2;
        scene.add(crossbar);

        // Definir el segundo arco (lado z = 2.3)
        const leftPost2Geometry = new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32);
        const leftPost2 = new THREE.Mesh(leftPost2Geometry, postMaterial);
        leftPost2.position.set(-goalWidth / 2, goalHeight / 2, 2.3);
        scene.add(leftPost2);

        const rightPost2Geometry = new THREE.CylinderGeometry(postRadius, postRadius, goalHeight, 32);
        const rightPost2 = new THREE.Mesh(rightPost2Geometry, postMaterial);
        rightPost2.position.set(goalWidth / 2, goalHeight / 2, 2.3);
        scene.add(rightPost2);

        const crossbar2Geometry = new THREE.CylinderGeometry(postRadius, postRadius, goalWidth, 32);
        const crossbar2 = new THREE.Mesh(crossbar2Geometry, postMaterial);
        crossbar2.position.set(0, goalHeight, 2.3);
        crossbar2.rotation.z = Math.PI / 2;
        scene.add(crossbar2);

        // Bounding boxes para colisiones
        const ballBox = new THREE.Box3();
        const leftPostBox = new THREE.Box3().setFromObject(leftPost);
        const rightPostBox = new THREE.Box3().setFromObject(rightPost);
        const crossbarBox = new THREE.Box3().setFromObject(crossbar);
        const leftPost2Box = new THREE.Box3().setFromObject(leftPost2);
        const rightPost2Box = new THREE.Box3().setFromObject(rightPost2);
        const crossbar2Box = new THREE.Box3().setFromObject(crossbar2);

        // Áreas de gol
        const goalArea1 = { // Primer arco
            minX: -goalWidth / 2,
            maxX: goalWidth / 2,
            minY: 0,
            maxY: goalHeight,
            minZ: -2.3 - goalDepth / 2,
            maxZ: -2.3 + goalDepth / 2,
        };

        const goalArea2 = { // Segundo arco
            minX: -goalWidth / 2,
            maxX: goalWidth / 2,
            minY: 0,
            maxY: goalHeight,
            minZ: 2.3 - goalDepth / 2,
            maxZ: 2.3 + goalDepth / 2,
        };

        function isBallInGoal() {
            if (!ball) return false;
            const ballPosition = ball.position;

            // Verificar gol en el primer arco
            const inGoal1 = (
                ballPosition.x >= goalArea1.minX && ballPosition.x <= goalArea1.maxX &&
                ballPosition.y >= goalArea1.minY && ballPosition.y <= goalArea1.maxY &&
                ballPosition.z >= goalArea1.minZ && ballPosition.z <= goalArea1.maxZ
            );

            // Verificar gol en el segundo arco
            const inGoal2 = (
                ballPosition.x >= goalArea2.minX && ballPosition.x <= goalArea2.maxX &&
                ballPosition.y >= goalArea2.minY && ballPosition.y <= goalArea2.maxY &&
                ballPosition.z >= goalArea2.minZ && ballPosition.z <= goalArea2.maxZ
            );

            if (inGoal1) {
                console.log("¡Gol en el arco 1!");
                ball.position.set(0, 0, 0); // Reiniciar al centro
                velocity.set(0, 0, 0);
                return true;
            } else if (inGoal2) {
                console.log("¡Gol en el arco 2!");
                ball.position.set(0, 0, 0); // Reiniciar al centro
                velocity.set(0, 0, 0);
                return true;
            }
            return false;
        }

        function checkCollisions() {
            if (!ball) return;
            ballBox.setFromObject(ball);

            // Colisiones con el primer arco
            if (ballBox.intersectsBox(leftPostBox)) {
                velocity.x = -velocity.x;
                velocity.z = -velocity.z;
                console.log('Colisión con poste izquierdo 1');
            }
            if (ballBox.intersectsBox(rightPostBox)) {
                velocity.x = -velocity.x;
                velocity.z = -velocity.z;
                console.log('Colisión con poste derecho 1');
            }
            if (ballBox.intersectsBox(crossbarBox)) {
                velocity.y = -velocity.y;
                velocity.z = -velocity.z;
                console.log('Colisión con travesaño 1');
            }

            // Colisiones con el segundo arco
            if (ballBox.intersectsBox(leftPost2Box)) {
                velocity.x = -velocity.x;
                velocity.z = -velocity.z;
                console.log('Colisión con poste izquierdo 2');
            }
            if (ballBox.intersectsBox(rightPost2Box)) {
                velocity.x = -velocity.x;
                velocity.z = -velocity.z;
                console.log('Colisión con poste derecho 2');
            }
            if (ballBox.intersectsBox(crossbar2Box)) {
                velocity.y = -velocity.y;
                velocity.z = -velocity.z;
                console.log('Colisión con travesaño 2');
            }
        }

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 5;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI / 2;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('mousedown', (event) => {
            event.preventDefault();
            console.log('Clic detectado');
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ball);
            console.log('Intersecciones:', intersects);
            if (intersects.length > 0) {
                velocity.set(
                    (Math.random() - 0.5) * speed,
                    0,
                    (Math.random() - 0.5) * speed
                );
            }
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (mixer) mixer.update(clock.getDelta());
            if (ball) {
                ball.position.x += velocity.x;
                ball.position.z += velocity.z;
                ball.position.y += velocity.y;

                if (ball.position.x > roomSizeX || ball.position.x < -roomSizeX) velocity.x = -velocity.x;
                if (ball.position.z > roomSizeZ || ball.position.z < -roomSizeZ) velocity.z = -velocity.z;
                if (ball.position.y < 0) {
                    ball.position.y = 0;
                    velocity.y = 0;
                }

                checkCollisions();
                isBallInGoal();

                velocity.multiplyScalar(0.99);
            }
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
